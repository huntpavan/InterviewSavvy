{
  "name": "C Programming",
  "logo": "C",
  "qalist": [
     {
       "question": "What is C language?",
       "answer": ["C is a general-purpose, block structured, procedural, imperative  programming language developed in 1972 by Dennis Ritchie to use with the Unix operating system.",
                  "<br><br>Block structured means that all the code is in terms of blocks (between { and }).",
                  "<br><br>Procedural means all the work is done in terms of procedure calls (method calls i.e. all code is in some method or another).",
                  "<br><br>Imperative means that the program is in terms of statements. (one after another).",
                  ""]
     },
     {
       "question": "What are the basic C operators?",
       "answer": ["The basic operators are arithmetic, logical, relational, and assignment. Binary operators take two operands, one on each side of the operator. Unary operators take one operand.",
                  "<br><br><b>Arithmetic:</b> a+b, a-b, a*b, a/b, a%b, ++a, a++, --a, a--.",
                  "<br><br><b>Logical:</b> a&&b, a||b, !a.",
                  "<br><br><b>Relational:</b> a&lt;b, a&gt;b, a&lt;=b, a&gt;=b, a!=b.",
                  "<br><br><b>Assignment:</b> lvaue = expr, lvalue += expr (similarly -=, *=, /=, %=).",
                  ""]
     },
     {
       "question": "What are the Bitwise Operators:",
       "answer": ["And (&)",
                  "<br><br>Or (|)",
                  "<br><br>Xor (^)",
                  "<br><br>Right shift (&gt;&gt;)",
                  "<br><br>Left shift (&lt;&lt;)",
                  "<br><br>Ones compliment (~)",
                  ""]
     },
     {
       "question": "What are the Keyboard/Screen/File IO functions?",
       "answer": ["The library stdio.h contains prototypes for the functions scanf, puts, gets and getchar which are used to get data from the keyboard and print data to the console screen. Here are the basic functions:",
                  "<br><br>printf, fprintf",
                  "<br><br>scanf, fscanf",
                  "<br><br>puts, fputs",
                  "<br><br>putchar, fputchar",
                  "<br><br>gets, fgets",
                  "<br><br>getchar, fgetc",
                  ""]
     },
     {
       "question": "What are the Conditional Statements?",
       "answer": ["Conditional statements are used to skip some statements depending on a test of some sort.",
                  "<br><br><b>if-else:</b> Test a condition and if true execute the is_true_block, otherwise execute the not_true_block.  The else is optional.",
                  "<br><br><b>Switch:</b> Jump immediately to a block of code depending on the value of an integer expression or  variable.",
                  ""]
     },
     {
       "question": "What are the Loop Statements?",
       "answer": ["It is often necessary to repeat the same block of C code multiple times. Loop statements are useful in such cases.",
                  "<br><br><b>while</b>",
                  "<br><br><b>do while</b>",
                  "<br><br><b>for</b>",
                  ""]
     },
     {
       "question": "What do break and continue keywords do?",
       "answer": ["<b>break:</b> When this statement is encountered, the program immediately exits the current control structure (while, for, do-while, or switch).  Execution continues with the first statement after the control structure.",
                  "<br><br><b>continue:</b> This statement causes control to immediately branch back to the beginning of a for, while, or do-while loop.",
                  ""]
     },
     {
       "question": "What is a Static variable?",
       "answer": ["Static is an access qualifier that limits the scope but causes the variable to exist for the lifetime of the program. This means a static variable is one that is not seen outside the function in which it is declared but which remains until the program terminates.",
                  "<br><br> It also means that the value of the variable persists between successive calls to a function. The value of such a variable will remain and may be seen even after calls to a function. One more thing is that a declaration statement of such a variable inside a function will be executed only once.",
                  ""]
     },
     {
       "question": "What is a pointer?",
       "answer": ["A pointer is a way to get at another object or variable. A pointer is actually just an address of where an instance is held in memory.",
                  ""]
     },
     {
       "question": "What is a Structure?",
       "answer": ["In C, a  structure is a derived data type consisting of a collection of member elements and their data types.",
                  "<br><br>Structure in C is like a class in an OOP language. It can define both data (property) and behavior (methods), except that the access modifier is public.",
                  "<br><br>It depends on the compilers whether you can have methods in C or not.",
                  ""]
     },
     {
       "question": "What is a Union?",
       "answer": ["A union type variable is like a structure that can store objects of different types at different times; however, at any given moment it stores an object of only one of the specified types.",
                  "<br><br>The declaration of a union type must specify all the possible different types that may be stored in the variable. The form of such a declaration is similar to declaring a structure template.",
                  ""]
     },
     {
       "question": "What the advantages of using Unions?",
       "answer": ["Unions conserves memory space. The amount of space allocated for union is based on the member which requires largest memory space.",
                  "<br><br>So unions are useful for applications involving number of variables, where values need not be assigned to all elements at one time.",
                  ""]
     },
     {
       "question": "What are the differences between Structures and Arrays?",
       "answer": ["Arrays are collections of data items of same type. Structures are complex data items that can be made up of data items of different types, including, potentially, other structures and arrays. You can, of course, also have arrays of structures.",
                  ""]
     },
     {
       "question": "What are the C Storage Classes?",
       "answer": ["Every C variable has a storage class and a scope. The storage class determines the part of memory where storage is allocated for a variable and how long the storage allocation continues to exist. It also determines the scope which specifies the part of the program over which a variable name is visible, i.e. the variable is accessible by name. The are four storage classes in C. They are:",
                  "<br><br><b>Automatic variables:</b> They are declared at the start of a block. Memory is allocated automatically upon entry to a block and freed automatically upon exit from the block. The scope of automatic variables is local to the block in which they are declared, including any blocks nested within that block. For these reasons, they are also called  local variables. No block outside the defining block may have direct access to automatic variables, i.e. by name. Of course, they may be accessed indirectly by other blocks and/or functions using pointers.",
                  "<br><br><b>Register variables:</b> Register variables are a special case of automatic variables. Automatic variables are allocated storage in the memory of the computer; however, for most computers, accessing data in memory is considerably slower than processing in the CPU. These computers often have small amounts of storage within the CPU itself where data can be stored and accessed quickly. These storage cells are called  registers.",
                  "<br><br><b>External variables:</b> They may be declared outside any function block in a source code file the same way any other variable is declared; by specifying its type and name. No storage class specifier is used - the position of the declaration within the file indicates external storage class. Memory for such variables is allocated when the program begins execution, and remains allocated until the program terminates. For most C implementations, every byte of memory allocated for an external variable is initialized to zero",
                  "<br><br><b>Static variables:</b> The storage class, static, similarly provides a lifetime over the entire program, however; it provides a way to limit the scope of such variables, Static storage class is declared with the keyword static as the class specifier when the variable is defined.",
                  ""]
     },
     {
       "question": "What is difference between variable declaration and definition?",
       "answer": ["<b>Variable declaration:</b> To give information about the variable, like its name and its type",
                  "<br><br><b>Variable definition:</b> Allocation of storage for a variable is its definition.",
                  "<br><br>For automatic and register variables, there is no difference between definition and declaration. When you say int a; inside a block both declaration and definition is taking place.",
                  "<br><br>External variables may be defined and declared with a declaration statement outside any function, with no storage class specifier. Such a declaration allocates memory for the variable.",
                  "<br><br>A declaration statement may also be used to simply  declare a variable name with the extern storage class specifier at the beginning of the declaration. Such a declaration specifies that the variable is  defined elsewhere, i.e. memory for this variable is allocated in another file. ",
                  ""
                  ]
     },
     {
       "question": "Are functions declared or defined in a header file?",
       "answer": ["In header files the functions are declared not defined. Function declaration means giving the information about the function like its name, types of aruguments (or parameters) and its return type. Function definition apart from the declaration, it also specifies the code (behavior) of the function.",
                  ""]
     },
     {
       "question": "What are the differences between malloc() and calloc()?",
       "answer": ["Malloc allocates bytes of memory. It takes a single argument i.e. memory required in bytes. Ex: Allocating memory for an integer array of size 10:",
                  "<br><br>int* var = (int*) malloc(10 * sizeof(int))",
                  "<br><br>It does not initialize the memory allocated.",
                  "<br><br>Calloc allocates block of memory. It takes two arguments i.e. number of variables to allocate memory, size in bytes of a single variable. Ex: ",
                  "<br><br>int* var = (int*)calloc(sizeof(int),10)",
                  "<br><br>It initializes the memory to zeros.",
                  "<br><br>Calloc(m, n) is essentially equivalent to p = malloc(m * n); memset(p, 0, m * n);",
                  ""]
     },
     {
       "question": "What are Preprocessor Directives?",
       "answer": ["Preprocessor directives are lines included in the code of our programs that are not program statements but directives for the preprocessor. These lines are always preceded by a hash sign (#).",
                  "<br><br>The preprocessor is executed before the actual compilation of code begins, therefore the preprocessor digests all these directives before any code is generated by the statements.",
                  "<br><br>The different types of directives are:",
                  "<br><br>macro definitions (#define, #undef)",
                  "<br><br>Conditional inclusions (#ifdef, #ifndef, #if, #endif, #else and #elif)",
                  "<br><br>Line control (#line)",
                  "<br><br>Error directive (#error)",
                  "<br><br>Source file inclusion (#include)",
                  "<br><br>Pragma directive (#pragma)",
                  ""]
     },
     {
       "question": "What are macros? What are the advantages and disadvantages?",
       "answer": ["Macro is a Pre-processor.",
                  "<br><br>Ex: #define ARRAY_SIZE 100; This replaces ARRAY_SIZE with 100 anywhere in the program.",
                  "<br><br>EX: #define SQR(x) (x * x); Here x is a parameter and replaces any expression like SQR(x) with square of x i.e. if SQR(2) is used in the code, then it is replaced by 4.",
                  "<br><br>The main advantage of using the macro is the speed of the execution of the program (if macro is not used in the program many times or if the program is small). The main disadvantage of the macro is it increase the size of the program because the pre-processor will replace all the macro name in the program by it actual definition before the compilation of the program.",
                  ""]
     },
     {
       "question": "What is Casting?",
       "answer": ["C type casting is used to tell the C compiler to treat a variable as of a different type in a specific context. The compiler will automatically change one type of data into another if it makes sense. ",
                  "<br><br>For instance, if you assign an integer value to a floating-point variable, the compiler will insert code to convert the int to a float. Casting allows you to make this type conversion explicit, or to force it when it would not normally happen.",
                  "<br><br>Ex: long int foo = 314159265L;",
                  "<br>double bar = foo; //implicit casting",
                  "<br>IsLowerCase = islower((unsigned char)*p); //explicit casting",
                  ""]
     },
     {
       "question": "What is the difference between char *a and char a[]?",
       "answer": ["char a[] = \"string\";",
                  "<br><br>char *a = \"string\";",
                  "<br><br>The declaration char a[] asks for space for 7 characters and see that its known by the name \"a\". In contrast, the declaration char *a, asks for a place that holds a pointer, to be known by the name \"a\". This pointer \"a\" can point anywhere. In this case its pointing to an anonymous array of 7 characters, which does have any name in particular. Its just present in memory with a pointer keeping track of its location",
                  ""]
     },
     {
       "question": "What is a memory leak?",
       "answer": ["Memory leak is unintentional memory consumption by a computer program, where the program fails to release the memory when no longer needed. This condition is normally the result of a bug in a program that prevents it from freeing up memory that it no longer needs.",
                  ""]
     },
     {
       "question": "What is the difference between pass by reference and pass by value?",
       "answer": ["Pass by value means we are passing the values in local variables which may loose their value due to stack operation.",
                  "<br><br>Pass by reference means we are sending the addresses of the variables. So they will retain their values.",
                  "<br><br>In Pass by value, the value changed in the variables in called function are not reflected in the same variables in calling function whereas in call by reference, it is reflected. Call by reference uses aliases to the variables. Reference means alias.",
                  ""]
     },
     {
       "question": "What is the difference between arrays and linked list?",
       "answer": ["Linked list consists of data nodes, each pointing to the next in the list. An array consists of contiguous chunks memory of predetermined size.",
                  "<br><br>Linked lists are quite flexible. They can grow to any size -- up to resource (memory) limits -- and each node can be a different size. Memory allocation for a node is done as needed, usually when a new node is added. Linked lists can be circular, or doubly-linked (pointers forward and backward), and new nodes can be inserted anywhere in the chain. The greatest downside to linked lists is sequential access: to find any node in memory, each previous node must be examined and the pointers followed. Linked lists are also more complex to program and manage.",
                  "<br><br>Arrays are fixed in size, so resources must be anticipated and consumed in advance. Each element is the same size and must contain the same data type. But access to a particular element is very fast, because its location in memory can be determined mathematically and accessed directly (offset from start of array = subscript * element size).",
                  "<br><br>Note that modern languages -- especially OO languages such as C++ and Java -- blur this distinction by providing classes which offer the best of both worlds. Arrays can grow; linked list complexity is hidden from the programmer; hash tables (special arrays, really) allow for rapid indexing of arbitrary data. But under the hood, each complex data type is implemented using primitives such as arrays and linked lists.",
                  ""]
     },
     {
       "question": "What are enumerations (enum)?",
       "answer": ["An enumeration is a type that can hold a set of constant values that are defined by the user. Once you define an enumeration you can use it like integer types.",
                  "<br><br>Ex: enum {OFF, ON}; The enum defines two integer constants called enumerators and these constants are assigned values by default. The value assigned to OFF = 0 and ON = 1. The above is an unnamed enumeration, however an enum can be named. Ex: enum STATE {OFF, ON}; Each enumeration is a distinct type and the type of the enumeration is the enumerator. For example OFF is of type STATE.",
                  ""]
     },
     {
       "question": "What is the use of typedef?",
       "answer": ["It allows you to introduce synonyms for types which could have been declared some other way. The new name becomes equivalent to the type that you wanted.",
                  ""]
     },
     {
       "question": "Out of fgets() and gets() which function is safe to use and why?",
       "answer": ["<b>gets():</b> It is a method to get some input from the user/keyboard. char *gets(char *s); It takes one and only parameter and it is a char pointer. gets() does not know how big the array is, and it is impossible to determine this from the pointer alone. If the user enter more characters than expected, gets() will not stop writing at the end of the array. Instead, it continues writing past the end and into memory it doesn't own.",
                  "<br><br><b>fgets():</b> fgets() is a buffer safe function. char *fgets(char *s, int size, FILE *stream); ",
                  "<br><br>",
                  ""]
     },
     {
       "question": "Difference between strdup and strcpy?",
       "answer": ["Both these functions are used to create copies of strings.",
                  "<br><br><b>strcpy</b> - copy a string to a location you created (you create the location i.e. allocate memory, make sure that the source string will have enough room there and afterwards use strcpy to copy)",
                  "<br><br><b>strdup</b> - copy a string to a location that will be created by the function. The function will allocate space, make sure that your string will fit there and copy the string. Will return a pointer to the created area.",
                  ""]
     },
     {
       "question": "What is Recursion?",
       "answer": ["A recursive procedure or routine is one that has the ability to call itself. This usually means that it has the capability to save the condition it was in or the particular process it is serving when it calls itself (otherwise, any variable values that have been developed in executing the code are overlaid by the next iteration or go-through).",
                  "<br><br>Typically, this is done by saving values in registers or data area stacks before calling itself or at the beginning of the sequence where it has just been reentered.",
                  ""]
     },
     {
       "question": "What are the advantages of using pointers in a program?",
       "answer": ["Dynamic memory allocation is possible with pointers.",
                  "<br><br>Passing arrays and structures to functions.",
                  "<br><br>Passing addresses to functions. (pass by reference). Without this, function cannot return more than one value. But when the same function can modify many pointer variables and act as if it is returning more than one variable.",
                  "<br><br>Creating data structures such as trees, linked lists etc.",
                  ""]
     },
     {
       "question": "What is a Far pointer? Where do we use it?",
       "answer": ["A far pointer uses both the segment and the offset address to point to a location in memory. A near pointer in contrast uses only the offset address and the default segment. The far pointer can point to any location in memory, whereas the near pointer can only point to a nearby local address.",
                  "<br><br>Generally the memory is protected by operating system by segmenting it into segments. The whole application which runs on ones system is in user space and the remaining system resources are put in low memory. The Far pointer is the mechanism to manipulate such a memory, but be cautious it can lead to adverse effects.",
                  ""]
     },
     {
       "question": "What is a NULL Pointer? Is it same as an uninitialized pointer?",
       "answer": ["NULL pointer is pointer which is not pointing to anything in the memory.  NULL is defined as (void*)0. Usually a pointer is initialized to NULL. This is to tell that it is still doesn't have valid address.",
                  "<br><br>Uninitialised pointer is pointing to some memory location which is not assigned. Malloc returns an uninitialized pointer i.e. the memory address with the contents of the pointer as junk values.",
                  ""]
     },
     {
       "question": "What does the error ‘Null Pointer Assignment’ mean and what causes this error? ",
       "answer": ["A pointer variable holds the address of a location in memory. But if the pointer hasn't been given a valid address, you can't dereference it.",
                  "<br><br>A NULL pointer assignment is a runtime error. It occurs due to various reasons one is that your program has tried to access an illegal memory location. Illegal location means either the location is in the operating systems address space or in the other processes memory space. In stdio.h NULL is defined as 0.",
                  "<br><br>So whenever your program tries to access 0th location the operating system kills your program with runtime assignment error because  the 0th location is in the operating systems address space and operating system doesnt allow access to its address space  by user program.",
                  ""]
     },
     {
       "question": "What is the difference between an enumeration and a set of pre-processor directive like #define?",
       "answer": ["An enumeration defines a set of constants. In C an enumerator is of type int. Enumeration is useful to define a set of constants instead of using multiple pre-processor directives.",
                  ""]
     },
     {
       "question": "What are different ways of defining constants in C?",
       "answer": ["A constant is similar to a variable in the sense that it represents a memory location. It differs in that it cannot be reassigned a new value after initialization. In general, constants are a useful feature that can prevent program bugs and logic errors. Unintended modifications are prevented from occurring. The compiler will catch attempts to reassign new values to constants.",
                  "<br><br>There are 3 ways to define constants in C. They are:",
                  "<br><br><b>#define:</b> constants may be defined using the preprocessor directive #define.",
                  "<br><br><b>const keyword:</b> The second technique is to use the keyword const when defining a variable. When used the compiler will catch attempts to modify variables that have been declared const.",
                  "<br><br>const has two advantages over #define. The type of the constant is defined. This allows type checking by the compiler. Second, these constants are variables with a definite scope.",
                  "<br><br><b>Enum:</b> The third technique to declare constants is called enumeration. An enumeration defines a set of constants. In C an enumerator is of type int. C++ allows variables to be a new enumeration type, which allows the compiler to perform type and bound checking. Unfortunately, C does not provide this.",
                  ""]
     },
     {
       "question": "What do the ‘c’ and ‘v’ in argc and argv stand for?",
       "answer": ["'c' stands for count. 'v' stands for vector.",
                  "<br><br>agrc means argument count. argv means argument vector.",
                  "<br><br>They are local to main function.",
                  ""]
     },
     {
       "question": "What is object file? How can you access object file? How is it different from executable file?",
       "answer": ["Both object and executable files are binary files but the differences between those are:",
                  "<br><br>We can execute an executable file while we cannot execute an object file.",
                  "<br><br>An object file is a file where compiler has not yet linked to the libraries, so you get an object file just before linking to the libraries. So some of the symbols or function definitions are not yet resolved which are actually present in the libraries, and that's why we cannot execute it.",
                  "<br><br>Once an object file is linked with the library by the compiler, then all the symbols are resolved and we get an executable file which can be executed on the appropriate platform.",
                  ""]
     },
     {
       "question": "What is the difference between an lvalue and an rvalue?",
       "answer": ["The lvalue refers to the left-hand side of an assignment expression. It must always evaluate to a memory location.",
                  "<br><br>The rvalue represents the right-hand side of an assignment expression; it may have any meaningful combination of variables and constants.",
                  "<br><br>",
                  ""]
     }
  ]
}